/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * December 14, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _VERSION_OBJECT_RPM_HPP
#define _VERSION_OBJECT_RPM_HPP

#include "iVersionObjectInterface.hpp"
#include "stringHelper.h"
#include <cctype>
#include <cstring>
#include <iostream>
#include <limits.h>
#include <memory>
#include <regex>
#include <string>

/**
 * @brief Rpm data struct.
 *
 */
struct Rpm
{
    std::string rpmVersion; ///< RPM version.
};

/**
 * @brief VersionObjectRpm class.
 *
 */
class VersionObjectRpm final : public IVersionObject
{
private:
    static std::regex m_parserRegex;
    std::string m_rpmVersion;

    /**
     * Compares two RPM versions.
     *
     * This function follows the convention of the comparator functions used by
     * qsort().
     *
     * @see rpmvercmp.c
     *
     * @param rRpmVersion The second RPM version.
     *
     * @retval 0 If a and b are equal.
     * @retval <0 If a is smaller than b.
     * @retval >0 If a is greater than b.
     */
    int compareRpmVersion(const std::string& rRpmVersion) const
    {
        /* easy comparison to see if versions are identical */
        if (!m_rpmVersion.compare(rRpmVersion))
        {
            return 0;
        }
        const auto& lhs = m_rpmVersion;
        auto rhs = rRpmVersion; // NOLINT
        char* lhsStrAux = const_cast<char*>(lhs.c_str());
        char* rhsStrAux = const_cast<char*>(rhs.c_str());
        char* auxOne = lhsStrAux;
        char* auxTwo = rhsStrAux;
        char auxChrOne, auxChrTwo;
        int isNumber;

        /* loop through each version segment of lhsStrAux and rhsStrAux and compare them */
        while (*auxOne && *auxTwo)
        {
            while (*auxOne && !std::isalnum(*auxOne))
            {
                auxOne++;
            }
            while (*auxTwo && !std::isalnum(*auxTwo))
            {
                auxTwo++;
            }

            /* If we ran to the end of either, we are finished with the loop */
            if (!(*auxOne && *auxTwo))
            {
                break;
            }

            lhsStrAux = auxOne;
            rhsStrAux = auxTwo;

            /* grab first completely alpha or completely numeric segment */
            /* leave one and two pointing to the start of the alpha or numeric */
            /* segment and walk lhsStrAux and rhsStrAux to end of segment */
            if (std::isdigit(*lhsStrAux))
            {
                while (*lhsStrAux && std::isdigit(*lhsStrAux)) lhsStrAux++;
                while (*rhsStrAux && std::isdigit(*rhsStrAux)) rhsStrAux++;
                isNumber = 1;
            }
            else
            {
                while (*lhsStrAux && std::isalpha(*lhsStrAux)) lhsStrAux++;
                while (*rhsStrAux && std::isalpha(*rhsStrAux)) rhsStrAux++;
                isNumber = 0;
            }

            auxChrOne = *lhsStrAux;
            *lhsStrAux = '\0';
            auxChrTwo = *rhsStrAux;
            *rhsStrAux = '\0';

            if (auxOne == lhsStrAux)
            {
                return -1;
            }
            if (auxTwo == rhsStrAux)
            {
                return (isNumber ? 1 : -1);
            }

            if (isNumber)
            {
                while (*auxOne == '0')
                {
                    auxOne++;
                }

                while (*auxTwo == '0')
                {
                    auxTwo++;
                }

                if (std::strlen(auxOne) > std::strlen(auxTwo))
                {
                    return 1;
                }

                if (std::strlen(auxTwo) > std::strlen(auxOne))
                {
                    return -1;
                }
            }

            auto resultCmp = std::strcmp(auxOne, auxTwo);
            if (resultCmp)
            {
                return (resultCmp < 1 ? -1 : 1);
            }

            *lhsStrAux = auxChrOne;
            auxOne = lhsStrAux;
            *rhsStrAux = auxChrTwo;
            auxTwo = rhsStrAux;
        }

        /* this catches the case where all numeric and alpha segments have */
        /* compared identically but the segment sepparating characters were */
        if ((!*auxOne) && (!*auxTwo))
        {
            return 0;
        }

        /* whichever version still has characters left over wins */
        if (!*auxOne)
        {
            return -1;
        }
        else
        {
            return 1;
        }
    }

public:
    /**
     * @brief Static method to match a version string to a Rpm object.
     *
     * @param version version string to match.
     * @param output Rpm object to store the result.
     * @return true/false according to match condition.
     */
    static bool match(const std::string& version, Rpm& output)
    {
        std::smatch parserMatches;
        if ((std::regex_match(version, parserMatches, m_parserRegex) == false) || (parserMatches.size() != 4))
        {
            return false;
        }

        output.rpmVersion = version;

        return true;
    }
    /**
     * @brief Constructor.
     *
     * @param version version SemVer object.
     */
    explicit VersionObjectRpm(const Rpm& version)
        : m_rpmVersion {version.rpmVersion}
    {
    }
    // LCOV_EXCL_START
    ~VersionObjectRpm() override = default;
    // LCOV_EXCL_STOP

    /**
     * @brief Returns the VersionObjectType of this class.
     *
     * @return VersionObjectType.
     */
    VersionObjectType getType() override
    {
        return VersionObjectType::RPM;
    }

    /**
     * @brief Comparison operator ==.
     *
     * @param b comparison rhs object.
     * @return true/false according to equality condition.
     */
    bool operator==(const IVersionObject& b) const override
    {
        const auto* pB = dynamic_cast<const VersionObjectRpm*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }

        return compareRpmVersion(pB->m_rpmVersion) == 0;
    }

    /**
     * @brief Comparison operator <.
     *
     * @param b comparison rhs object.
     * @return true/false according to less than condition.
     */
    bool operator<(const IVersionObject& b) const override
    {
        const auto* pB = dynamic_cast<const VersionObjectRpm*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }
        return compareRpmVersion(pB->m_rpmVersion) == -1;
    }
};

#endif // _VERSION_OBJECT_RPM_HPP
