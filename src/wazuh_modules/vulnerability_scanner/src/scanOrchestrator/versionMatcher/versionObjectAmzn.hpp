/*
 * Wazuh Vulnerability scanner - Database Feed Manager
 * Copyright (C) 2015, Wazuh Inc.
 * December 28, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _VERSION_OBJECT_AMZN_HPP
#define _VERSION_OBJECT_AMZN_HPP

#include "iVersionObjectInterface.hpp"
#include <iostream>
#include <memory>
#include <regex>
#include <string>

/**
 * @brief Amzn data struct.
 *
 */
struct Amzn
{
    uint32_t epoch;   ///< Year.
    uint32_t major;   ///< Month.
    uint32_t minor;   ///< Day.
    uint32_t patch;   ///< Patch.
    uint32_t release; ///< Release.
};

/**
 * @brief VersionObjectAmzn class.
 *
 */
class VersionObjectAmzn final : public IVersionObject
{
private:
    static std::regex m_parserRegex;
    uint32_t m_epoch;
    uint32_t m_major;
    uint32_t m_minor;
    uint32_t m_patch;
    uint32_t m_release;

public:
    /**
     * @brief Static method to match a version string to a Amzn object.
     *
     * @param version version string to match.
     * @param output Amzn object to store the result.
     * @return true/false according to match condition.
     */
    static bool match(const std::string& version, Amzn& output)
    {
        std::smatch parserMatches;
        if ((std::regex_search(version, parserMatches, m_parserRegex) == false) || (parserMatches.size() != 5))
        {

            output.epoch = parserMatches.str(1).empty() ? 0 : static_cast<uint32_t>(std::stoul(parserMatches.str(1)));
            output.major = parserMatches.str(2).empty() ? 0 : static_cast<uint32_t>(std::stoul(parserMatches.str(2)));
            output.minor = parserMatches.str(3).empty() ? 0 : static_cast<uint32_t>(std::stoul(parserMatches.str(3)));
            output.patch = parserMatches.str(4).empty() ? 0 : static_cast<uint32_t>(std::stoul(parserMatches.str(4)));
            output.release = parserMatches.str(5).empty() ? 0 : static_cast<uint32_t>(std::stoul(parserMatches.str(5)));
            return true;
        }

        return false;
    }
    /**
     * @brief Constructor.
     *
     * @param version version SemVer object.
     */
    explicit VersionObjectAmzn(const Amzn& version)
        : m_epoch {version.epoch}
        , m_major {version.major}
        , m_minor {version.minor}
        , m_patch {version.patch}
        , m_release {version.release}
    {
    }
    // LCOV_EXCL_START
    ~VersionObjectAmzn() override = default;
    // LCOV_EXCL_STOP

    /**
     * @brief Returns the VersionObjectType of this class.
     *
     * @return VersionObjectType.
     */
    VersionObjectType getType() override
    {
        return VersionObjectType::AMZN;
    }

    /**
     * @brief Comparison operator ==.
     *
     * @param b comparison rhs object.
     * @return true/false according to equality condition.
     */
    bool operator==(const IVersionObject& b) const override
    {
        const auto* pB = dynamic_cast<const VersionObjectAmzn*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }
        return (m_epoch == pB->m_epoch && m_major == pB->m_major && m_minor == pB->m_minor && m_patch == pB->m_patch &&
                m_release == pB->m_release);
    }

    /**
     * @brief Comparison operator <.
     *
     * @param b comparison rhs object.
     * @return true/false according to less than condition.
     */
    bool operator<(const IVersionObject& b) const override
    {
        const auto* pB = dynamic_cast<const VersionObjectAmzn*>(&b);
        if (pB == nullptr)
        {
            throw std::runtime_error {"Error casting VersionObject type"};
        }

        if (m_epoch != pB->m_epoch)
        {
            return m_epoch < pB->m_epoch;
        }

        else if (m_major != pB->m_major)
        {
            return m_major < pB->m_major;
        }

        else if (m_minor != pB->m_minor)
        {
            return m_minor < pB->m_minor;
        }

        else if (m_patch != pB->m_patch)
        {
            return m_patch < pB->m_patch;
        }

        return m_release < pB->m_release;
    }
};

#endif // _VERSION_OBJECT_AMZN_HPP
