/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * Jun 1, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _INVENTORY_SYNC_HPP
#define _INVENTORY_SYNC_HPP

#include "../policyManager/policyManager.hpp"
#include "chainOfResponsability.hpp"
#include "rocksDBWrapper.hpp"
#include "scanContext.hpp"

/**
 * @brief TInventorySync class.
 *
 * @tparam TScanContext scan context type.
 */
template<typename TScanContext = ScanContext>
class TInventorySync final : public AbstractHandler<std::shared_ptr<TScanContext>>
{
private:
    Utils::RocksDBWrapper& m_inventoryDatabase;

public:
    // LCOV_EXCL_START
    /**
     * @brief InventorySync constructor.
     *
     * @param inventoryDatabase Inventory database.
     */
    explicit TInventorySync(Utils::RocksDBWrapper& inventoryDatabase)
        : m_inventoryDatabase(inventoryDatabase)
    {
    }

    /**
     * @brief Handles request and passes control to the next step of the chain.
     *
     * @param data Scan context.
     * @return std::shared_ptr<ScanContext> Abstract handler.
     */
    std::shared_ptr<TScanContext> handleRequest(std::shared_ptr<TScanContext> data) override
    {
        std::string agentPackageKey;
        agentPackageKey.append(data->agentNodeName());
        agentPackageKey.append("_");
        agentPackageKey.append(data->agentId());
        agentPackageKey.append("_");

        if (data->operationType() == OperationType::DeleteAll)
        {
            data->m_isInventoryEmpty = true;
            for (const auto& dbQuery : m_inventoryDatabase.seek(agentPackageKey))
            {
                auto listCve = Utils::split(dbQuery.second.ToString(), ',');
                for (const auto& cve : listCve)
                {
                    data->m_isInventoryEmpty = false;
                    std::string elementKey;
                    nlohmann::json json;
                    elementKey.append(dbQuery.first);
                    elementKey.append("_");
                    elementKey.append(cve);
                    json["operation"] = "DELETED";
                    json["id"] = elementKey;
                    data->m_elements[elementKey] = std::move(json);
                }
                logDebug2(WM_VULNSCAN_LOGTAG, "Deleting all agent packages key: %s", dbQuery.first.c_str());
                m_inventoryDatabase.delete_(dbQuery.first);
            }
        }
        else if (data->operationType() == OperationType::Delete)
        {
            agentPackageKey.append(data->packageItemId());
            std::string value;
            if (m_inventoryDatabase.get(agentPackageKey, value))
            {
                auto listCve = Utils::split(value, ',');
                for (const auto& cve : listCve)
                {
                    std::string elementKey;
                    nlohmann::json json;
                    elementKey.append(agentPackageKey);
                    elementKey.append("_");
                    elementKey.append(cve);
                    json["operation"] = "DELETED";
                    json["id"] = elementKey;
                    data->m_elements[elementKey] = std::move(json);
                    data->m_alerts[cve] = nlohmann::json::object();
                }
                logDebug2(WM_VULNSCAN_LOGTAG, "Deleting agent package key: %s", agentPackageKey.c_str());
                m_inventoryDatabase.delete_(agentPackageKey);
            }
        }
        else if (data->operationType() == OperationType::Insert)
        {
            agentPackageKey.append(data->packageItemId());
            std::vector<std::string> insertList;
            std::string insertListString;
            std::string value;

            if (m_inventoryDatabase.get(agentPackageKey, value))
            {
                auto listCve = Utils::split(value, ',');
                for (auto& [key, value] : data->m_elements)
                {
                    if (std::find(listCve.begin(), listCve.end(), key) == listCve.end())
                    {
                        // Concatenate all cves to insert into the inventory.
                        insertListString.append(key);
                        insertListString.append(",");
                    }
                }

                if (!insertListString.empty())
                {
                    insertListString.append(value);
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "Updating agent package key: %s -> %s",
                              agentPackageKey.c_str(),
                              insertListString.c_str());
                    m_inventoryDatabase.put(agentPackageKey, insertListString);
                }
            }
            else
            {
                for (auto& [key, value] : data->m_elements)
                {
                    // Concatenate all cves to insert into the inventory.
                    insertListString.append(key);
                    insertListString.append(",");
                }

                if (!insertListString.empty())
                {
                    insertListString.pop_back();
                    logDebug2(WM_VULNSCAN_LOGTAG,
                              "Inserting agent package key: %s -> %s",
                              agentPackageKey.c_str(),
                              insertListString.c_str());
                    m_inventoryDatabase.put(agentPackageKey, insertListString);
                }
            }
        }

        return AbstractHandler<std::shared_ptr<TScanContext>>::handleRequest(std::move(data));
    }
    // LCOV_EXCL_STOP
};

using InventorySync = TInventorySync<>;

#endif // _INVENTORY_SYNC_HPP
