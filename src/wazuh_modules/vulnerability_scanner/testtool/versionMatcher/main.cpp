/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * Dec 20, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "argsParser.hpp"
#include "cve5_generated.h"
#include "databaseFeedManager.hpp"
#include "json.hpp"
#include "loggerHelper.h"
#include "routerModule.hpp"
#include "routerProvider.hpp"
#include "singleton.hpp"
#include "versionMatcher/versionMatcher.hpp"
#include <filesystem>
#include <iostream>

/**
 * @brief Dummy class to replace real IndexerConnector.
 *
 */
class DummyIndexerConnector
{
public:
    /**
     * @brief No operation method.
     *
     * @param message
     */
    void publish(const std::string& message) {}
};

/**
 * @brief Dummy class to replace real PolicyManager.
 *
 */
class DummyPolicyManager : public Singleton<DummyPolicyManager>
{
public:
    /**
     * @brief This method sets the topic for the subscriber.
     *
     * @param topic The topic to subscribe to.
     */
    void setUpdaterConfiguration(const std::string& topic)
    {
        m_topic = topic;
    }

    /**
     * @brief Retrieves the UpdaterConfiguration.
     *
     * @return nlohmann::json A simple JSON object with the configured topic.
     */
    nlohmann::json getUpdaterConfiguration()
    {
        auto updaterConfiguration = nlohmann::json::object();
        updaterConfiguration["topicName"] = m_topic;
        return updaterConfiguration;
    }

    /**
     * @brief Get translation LRU size.
     *
     * @return uint32_t translation LRU size.
     */
    uint32_t getTranslationLRUSize() const
    {
        return 2048;
    }

    /**
     * @brief Get osdata LRU size.
     *
     * @return uint32_t osdata LRU size.
     */
    uint32_t getOsdataLRUSize() const
    {
        return 1000;
    }

private:
    std::string m_topic;
};

/**
 * @brief Dummy class to replace real ContentRegister.
 *
 */
class DummyContentRegister
{
public:
    /**
     * @brief Constructor of the dummy class
     *
     * @param obj1 Not used.
     * @param obj2 Not used.
     */
    DummyContentRegister(const nlohmann::json& obj1, const nlohmann::json& obj2) {}

    /**
     * @brief No operation method.
     *
     * @param interval Not used.
     */
    void changeSchedulerInterval(long unsigned int interval) {}
};

/**
 * @brief Creates a version object using the string and type specified. Copy from version matcher due this method is
 * private
 *
 * @param version string version item to create object from
 * @param type version object type to create from enum VersionObjectType
 * @return std::shared_ptr<IVersionObject>
 */
std::shared_ptr<IVersionObject> createVersionObject(const std::string& version, VersionObjectType type)
{
    CalVer calVer {};
    PEP440 pep440 {};
    MajorMinor majorMinor {};
    SemVer semVer {};
    Dpkg dpkgVer {};
    Rpm rpmVer {};
    Amzn amznVer {};
    switch (type)
    {
        default: logDebug2(WM_VULNSCAN_LOGTAG, "Error creating VersionObject: Invalid type."); return nullptr;
        case VersionObjectType::Unspecified:
            if (VersionObjectCalVer::match(version, calVer))
            {
                return std::make_shared<VersionObjectCalVer>(calVer);
            }
            else if (VersionObjectPEP440::match(version, pep440))
            {
                return std::make_shared<VersionObjectPEP440>(pep440);
            }
            else if (VersionObjectMajorMinor::match(version, majorMinor))
            {
                return std::make_shared<VersionObjectMajorMinor>(majorMinor);
            }
            else if (VersionObjectRpm::match(version, rpmVer))
            {
                return std::make_shared<VersionObjectRpm>(rpmVer);
            }
            else if (VersionObjectDpkg::match(version, dpkgVer))
            {
                return std::make_shared<VersionObjectDpkg>(dpkgVer);
            }
            else if (VersionObjectSemVer::match(version, semVer))
            {
                return std::make_shared<VersionObjectSemVer>(semVer);
            }
            else if (VersionObjectAmzn::match(version, amznVer))
            {
                return std::make_shared<VersionObjectAmzn>(amznVer);
            }
            else
            {
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Error creating VersionObject (Unspecified). Unrecognized type. Version string: %s",
                          version.c_str());

                return nullptr;
            }
            break;

        case VersionObjectType::CalVer:
            if (VersionObjectCalVer::match(version, calVer))
            {
                return std::make_shared<VersionObjectCalVer>(calVer);
            }
            else
            {
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Error creating VersionObject (CalVer). Version string doesn't match the specified type. "
                          "Version string: %s",
                          version.c_str());

                return nullptr;
            }
            break;

        case VersionObjectType::PEP440:
            if (VersionObjectPEP440::match(version, pep440))
            {
                return std::make_shared<VersionObjectPEP440>(pep440);
            }
            else
            {
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Error creating VersionObject (PEP440). Version string doesn't match the specified type. "
                          "Version string: %s",
                          version.c_str());
                return nullptr;
            }
            break;
        case VersionObjectType::MajorMinor:
            if (VersionObjectMajorMinor::match(version, majorMinor))
            {
                return std::make_shared<VersionObjectMajorMinor>(majorMinor);
            }
            else
            {
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Error creating VersionObject (MajorMinor). Version string doesn't match the specified type. "
                          "Version string: %s",
                          version.c_str());
                return nullptr;
            }
            break;

        case VersionObjectType::SemVer:
            if (VersionObjectSemVer::match(version, semVer))
            {
                return std::make_shared<VersionObjectSemVer>(semVer);
            }
            else
            {
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Error creating VersionObject (SemVer). Version string doesn't match the specified type. "
                          "Version string: %s",
                          version.c_str());
                return nullptr;
            }
            break;
        case VersionObjectType::DPKG:
            if (VersionObjectDpkg::match(version, dpkgVer))
            {
                return std::make_shared<VersionObjectDpkg>(dpkgVer);
            }
            else
            {
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Error creating VersionObject (DPKG). Version string doesn't match the specified type. "
                          "Version string: %s",
                          version.c_str());
                return nullptr;
            }
            break;
        case VersionObjectType::RPM:
            if (VersionObjectRpm::match(version, rpmVer))
            {
                return std::make_shared<VersionObjectRpm>(rpmVer);
            }
            else
            {
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Error creating VersionObject (RPM). Version string doesn't match the specified type. "
                          "Version string: %s",
                          version.c_str());
                return nullptr;
            }
            break;
        case VersionObjectType::AMZN:
            if (VersionObjectAmzn::match(version, amznVer))
            {
                return std::make_shared<VersionObjectAmzn>(amznVer);
            }
            else
            {
                logDebug2(WM_VULNSCAN_LOGTAG,
                          "Error creating VersionObject (AMZN). Version string doesn't match the specified type. "
                          "Version string: %s",
                          version.c_str());
                return nullptr;
            }
            break;
    }
}

enum TypeVersion
{
    REGULAR,
    LESS_THAN,
    LESS_THAN_OR_EQUAL
};

int main(const int argc, const char* argv[])
{
    try
    {

        // LOGLEVEL_INFO, tag, sourceFile.file, sourceFile.line, sourceFile.func, formattedStr
        Log::assignLogFunction(
            [](const int,
               const std::string& tag,
               const std::string& file,
               const int line,
               const std::string&,
               const std::string& str,
               va_list args)
            {
                char formattedStr[MAXLEN] = {0};
                vsnprintf(formattedStr, MAXLEN, str.c_str(), args);
                std::cout << tag << "->" << file << ":" << line << " " << formattedStr << std::endl;
            });
        // Reset required directories
        if (std::filesystem::exists("./queue/vd"))
        {
            if (std::remove("./queue/vd") != 0)
            {
                std::cerr << "Error deleting directory ./queue/vd" << std::endl;
            }
        }
        std::filesystem::create_directories("./queue/vd");

        CmdLineArgs cmdLineArgs(argc, argv);

        // Read json configuration file
        auto configuration = nlohmann::json::parse(std::ifstream(cmdLineArgs.getConfigurationFilePath()));

        RouterModule::instance().start();
        auto routerProvider = std::make_shared<RouterProvider>(configuration.at("topicName"));
        routerProvider->start();

        DummyPolicyManager::instance().setUpdaterConfiguration(configuration.at("topicName"));
        std::shared_mutex mutex;
        std::atomic<bool> shouldStop {false};

        auto databaseFeedManager =
            std::make_shared<TDatabaseFeedManager<DummyIndexerConnector, DummyPolicyManager, DummyContentRegister>>(
                std::make_shared<DummyIndexerConnector>(), shouldStop, mutex, false);

        auto baseLine = R"(
        {
            "paths":
            [
            ],
            "stageStatus":
            [
                {
                    "stage": "download",
                    "status": "ok"
                }
            ]
        }
        )"_json;

        baseLine["type"] = cmdLineArgs.getFormatInputFiles();
        for (const auto& path : cmdLineArgs.getInputFiles())
        {
            baseLine["paths"].push_back(path);
        }

        const auto payload = baseLine.dump();
        const auto message = std::vector<char>(payload.begin(), payload.end());

        routerProvider->send(message);
        if (cmdLineArgs.getWaitTime() > 0)
        {
            std::this_thread::sleep_for(std::chrono::seconds(cmdLineArgs.getWaitTime()));
        }
        else
        {
            std::cout << "Press enter to stop the tool..." << std::endl;
            if (!cmdLineArgs.getConfigurationVersionMatcher().compare("yes"))
            {
                uint64_t amountStringVersion {0};
                uint64_t amountStringVersionLess {0};
                uint64_t amountStringVersionLessOrEqual {0};
                uint64_t totalPackages {0};
                std::cout << "Verification process enabled. Press enter to start" << std::endl;
                std::cin.get();
                auto printValue = [&](const std::string& version,
                                      const std::string& packageName,
                                      const std::string& cve,
                                      TypeVersion versionCase)
                {
                    switch (versionCase)
                    {
                        case TypeVersion::REGULAR:
                            std::cout << "=== WARNING === \t Package with vendor '" << packageName
                                      << "' unable to create. INFO: Regular version ==> " << version << " CVE ==> "
                                      << cve << "\n"
                                      << std::endl;
                            break;
                        case TypeVersion::LESS_THAN:
                            std::cout << "=== WARNING === \t Package with vendor '" << packageName
                                      << "' unable to create. INFO: Less than version ==> " << version << " CVE ==> "
                                      << cve << "\n"
                                      << std::endl;
                            break;
                        case TypeVersion::LESS_THAN_OR_EQUAL:
                            std::cout << "=== WARNING === \t Package with vendor '" << packageName
                                      << "' unable to create. INFO: Less than pr equal version ==> " << version
                                      << " CVE ==> " << cve << "\n"
                                      << std::endl;
                            break;
                    };
                };

                VersionObjectType type = VersionObjectType::Unspecified;

                for (const auto& [key, value] : databaseFeedManager->getCVEDatabase().begin())
                {
                    auto entryCve = cve_v5::GetEntry(value.data());
                    if (entryCve->containers())
                    {
                        auto adpVector = entryCve->containers()->adp();
                        if (adpVector && entryCve->containers()->cna())
                        {
                            for (const auto& adpData : *adpVector)
                            {
                                if (adpData)
                                {
                                    auto affectedVector = adpData->affected();
                                    if (affectedVector)
                                    {
                                        for (const auto& affectedElement : *affectedVector)
                                        {
                                            auto versionVector = affectedElement->versions();
                                            if (versionVector)
                                            {
                                                for (const auto& versionElement : *versionVector)
                                                {
                                                    std::string versionString {versionElement->version()
                                                                                   ? versionElement->version()->str()
                                                                                   : ""};
                                                    std::string versionStringLessThan {
                                                        versionElement->lessThan() ? versionElement->lessThan()->str()
                                                                                   : ""};
                                                    std::string versionStringLessThanOrEqual {
                                                        versionElement->lessThanOrEqual()
                                                            ? versionElement->lessThanOrEqual()->str()
                                                            : ""};
                                                    std::string vendorId {affectedElement->vendor()
                                                                              ? affectedElement->vendor()->str()
                                                                              : "UNKNOW VENDOR"};

                                                    totalPackages++;
                                                    if (versionStringLessThan.empty() &&
                                                        versionStringLessThanOrEqual.empty())
                                                    {
                                                        auto pVersionObject = createVersionObject(versionString, type);
                                                        if (!pVersionObject)
                                                        {
                                                            printValue(versionString,
                                                                       vendorId,
                                                                       entryCve->cveMetadata()->cveId()->str(),
                                                                       TypeVersion::REGULAR);
                                                            amountStringVersion++;
                                                        }
                                                    }
                                                    else if (!versionStringLessThan.empty() &&
                                                             versionStringLessThan.compare("*") != 0)
                                                    {
                                                        auto pVersionObject =
                                                            createVersionObject(versionStringLessThan, type);
                                                        if (!pVersionObject)
                                                        {
                                                            printValue(versionStringLessThan,
                                                                       vendorId,
                                                                       entryCve->cveMetadata()->cveId()->str(),
                                                                       TypeVersion::LESS_THAN);
                                                            amountStringVersionLess++;
                                                        }
                                                    }
                                                    else if (!versionStringLessThanOrEqual.empty())
                                                    {
                                                        auto pVersionObject =
                                                            createVersionObject(versionStringLessThanOrEqual, type);
                                                        if (!pVersionObject)
                                                        {
                                                            printValue(versionStringLessThanOrEqual,
                                                                       vendorId,
                                                                       entryCve->cveMetadata()->cveId()->str(),
                                                                       TypeVersion::LESS_THAN_OR_EQUAL);
                                                            amountStringVersionLessOrEqual++;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if (totalPackages == 0)
                {
                    std::cout << "No packages found" << std::endl;
                }
                else
                {
                    std::cout << "=== Total packages analyzed summary ===\n"
                              << "\t Total packages: " << totalPackages << "\n"
                              << "\t Invalid stringVersions: " << amountStringVersion << " ("
                              << ((double)amountStringVersion / (double)totalPackages) * 100 << ")%\n"
                              << "\t Invalid stringVersionsLess: " << amountStringVersionLess << " ("
                              << ((double)amountStringVersionLess / (double)totalPackages) * 100 << ")%\n"
                              << "\t Invalid stringVersionsLessOrEqual: " << amountStringVersionLessOrEqual << " ("
                              << ((double)amountStringVersionLessOrEqual / (double)totalPackages) * 100 << ")%\n"
                              << std::endl;
                }
            }
            std::cin.get();
            databaseFeedManager.reset();
        }
    }
    catch (const std::exception& e)
    {
        std::cerr << e.what() << std::endl;
        CmdLineArgs::showHelp();
        return 1;
    }
    return 0;
}
