/*
 * Wazuh Vulnerability scanner
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#include "argsParser.hpp"
#include "contentManager.hpp"
#include "flatbuffers/idl.h"
#include "flatbuffers/include/syscollector_deltas_generated.h"
#include "flatbuffers/include/syscollector_deltas_schema.h"
#include "flatbuffers/include/syscollector_synchronization_generated.h"
#include "flatbuffers/include/syscollector_synchronization_schema.h"
#include "routerModule.hpp"
#include "routerProvider.hpp"
#include "vulnerabilityScanner.hpp"
#include <iostream>
#include <thread>

auto constexpr MAXLEN {65536};

int main(const int argc, const char* argv[])
{
    try
    {
        auto& routerModule = RouterModule::instance();
        auto& vulnerabilityScanner = VulnerabilityScanner::instance();
        CmdLineArgs cmdLineArgs(argc, argv);

        // Read json configuration file
        auto configuration = nlohmann::json::parse(std::ifstream(cmdLineArgs.getConfigurationFilePath()));

        // If the template file path is provided, set in the configuration adding the template path.
        // Otherwise, the default template will be used.
        if (!cmdLineArgs.getTemplateFilePath().empty())
        {
            configuration["indexer"]["template_path"] = cmdLineArgs.getTemplateFilePath();
        }

        routerModule.start();

        auto routerProviderDbSync = RouterProvider("deltas-syscollector", true);
        auto routerProviderRSync = RouterProvider("rsync-syscollector", true);
        routerProviderDbSync.start();
        routerProviderRSync.start();

        vulnerabilityScanner.start(
            [](const int logLevel,
               const std::string& tag,
               const std::string& file,
               const int line,
               const std::string& func,
               const std::string& message,
               va_list args)
            {
                auto pos = file.find_last_of('/');
                if (pos != std::string::npos)
                {
                    pos++;
                }
                std::string fileName = file.substr(pos, file.size() - pos);
                char formattedStr[MAXLEN] = {0};
                vsnprintf(formattedStr, MAXLEN, message.c_str(), args);

                if (logLevel != LOG_ERROR)
                {
                    std::cout << tag << ":" << fileName << ":" << line << " " << func << " : " << formattedStr
                              << std::endl;
                }
                else
                {
                    std::cerr << tag << ":" << fileName << ":" << line << " " << func << " : " << formattedStr
                              << std::endl;
                }
            },
            configuration,
            false);

        if (!cmdLineArgs.getOnlyDownloadContent())
        {
            // Wait for the complete initialization and connection negotiation.
            std::this_thread::sleep_for(std::chrono::seconds(1));

            for (const auto& inputFile : cmdLineArgs.getInputFiles())
            {
                std::cout << "Processing file: " << inputFile << std::endl;
                // Parse inputFile JSON.
                const auto jsonInputFile = nlohmann::json::parse(std::ifstream(inputFile)).dump();

                flatbuffers::Parser parser;
                std::string jsonContent;
                bool isDelta = true;
                if (parser.Parse(syscollector_deltas_SCHEMA))
                {
                    if (parser.Parse(jsonInputFile.c_str()))
                    {
                        std::cout << "Syscollector delta parsed successfully" << std::endl;
                    }
                    else
                    {
                        if (parser.Parse(syscollector_synchronization_SCHEMA))
                        {
                            if (parser.Parse(jsonInputFile.c_str()))
                            {
                                isDelta = false;
                                std::cout << "Syscollector synchronization parsed successfully" << std::endl;
                            }
                            else
                            {
                                throw std::runtime_error("Failed to parse JSON input file. Reason: " + parser.error_);
                            }
                        }
                    }
                }

                std::cout << "size: " << parser.builder_.GetSize() << std::endl;
                // Convert to flatbuffer.
                std::vector<char> buffer {parser.builder_.GetBufferPointer(),
                                          parser.builder_.GetBufferPointer() + parser.builder_.GetSize()};
                isDelta ? routerProviderDbSync.send(buffer) : routerProviderRSync.send(buffer);
                // Wait for the complete initialization and connection negotiation.
                std::this_thread::sleep_for(std::chrono::seconds(1));
            }

            if (cmdLineArgs.getWaitTime() > 0)
            {
                std::this_thread::sleep_for(std::chrono::seconds(cmdLineArgs.getWaitTime()));
            }
            else
            {
                std::cout << "Press enter to stop the scanner..." << std::endl;
                std::cin.get();
            }
        }
        else
        {
            // Wait for the start of snapshot processing.
            std::this_thread::sleep_for(std::chrono::seconds(60));
        }

        routerProviderDbSync.stop();
        routerProviderRSync.stop();
        vulnerabilityScanner.stop();
        routerModule.stop();
        ContentModule::instance().stop();
    }
    catch (const std::exception& e)
    {
        std::cerr << e.what() << std::endl;
        CmdLineArgs::showHelp();
        return 1;
    }
    return 0;
}
