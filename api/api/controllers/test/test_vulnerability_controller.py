# Copyright (C) 2015, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is a free software; you can redistribute it and/or modify it under the terms of GPLv2

import sys
from unittest.mock import ANY, AsyncMock, MagicMock, patch

import pytest
from connexion.lifecycle import ConnexionResponse
from connexion.testing import TestContext
from api.controllers.test.utils import CustomAffectedItems

with patch('wazuh.common.wazuh_uid'):
    with patch('wazuh.common.wazuh_gid'):
        sys.modules['wazuh.rbac.orm'] = MagicMock()
        import wazuh.rbac.decorators
        from api.controllers.vulnerability_controller import get_last_scan_agent, get_vulnerability_agent, \
            get_vulnerabilities_field_summary, run_vulnerability_scan
        from wazuh import vulnerability
        from wazuh.core.common import DATABASE_LIMIT
        from wazuh.tests.util import RBAC_bypasser

        wazuh.rbac.decorators.expose_resources = RBAC_bypasser
        del sys.modules['wazuh.rbac.orm']

@pytest.fixture
def mock_request():
    """fixture to wrap functions with request"""
    operation = MagicMock(name="operation")
    operation.method = "post"
    with TestContext(operation=operation):
        with patch('api.controllers.vulnerability_controller.request') as m_req:
            m_req.query_params.get = lambda key, default: None
            m_req.context = {'token_info': {'rbac_policies': {}}}
            yield m_req


@pytest.mark.asyncio
@patch('api.controllers.vulnerability_controller.DistributedAPI.distribute_function', return_value=AsyncMock())
@patch('api.controllers.vulnerability_controller.DistributedAPI.__init__', return_value=None)
@patch('api.controllers.vulnerability_controller.raise_if_exc', return_value=CustomAffectedItems())
async def test_run_vulnerability_scan(mock_exc, mock_dapi, mock_dfunc, mock_request):
    """Verify 'get_vulnerability_agent' endpoint is working as expected."""
    result = await run_vulnerability_scan()
    mock_dapi.assert_called_once_with(f=vulnerability.run_vulnerability_scan,
                                      request_type='distributed_master',
                                      is_async=False,
                                      wait_for_complete=False,
                                      logger=ANY,
                                      rbac_permissions=mock_request.context['token_info']['rbac_policies'])
    mock_exc.assert_called_once_with(mock_dfunc.return_value)
    assert isinstance(result, ConnexionResponse)


@pytest.mark.asyncio
@patch('api.controllers.vulnerability_controller.DistributedAPI.distribute_function', return_value=AsyncMock())
@patch('api.controllers.vulnerability_controller.remove_nones_to_dict')
@patch('api.controllers.vulnerability_controller.DistributedAPI.__init__', return_value=None)
@patch('api.controllers.vulnerability_controller.raise_if_exc', return_value=CustomAffectedItems())
async def test_get_vulnerability_agent(mock_exc, mock_dapi, mock_remove, mock_dfunc, mock_request):
    """Verify 'get_vulnerability_agent' endpoint is working as expected."""
    result = await get_vulnerability_agent()
    f_kwargs = {
        'agent_list': [None],
        'offset': 0,
        'limit': None,
        'sort': None,
        'search': None,
        'select': None,
        'q': '',
        'distinct': None,
        'filters': {
            'architecture': None,
            'cve': None,
            'name': None,
            'version': None,
            'status': None,
            'type': None,
            'severity': None
        }
    }
    mock_dapi.assert_called_once_with(f=vulnerability.get_agent_cve,
                                      f_kwargs=mock_remove.return_value,
                                      request_type='distributed_master',
                                      is_async=False,
                                      wait_for_complete=False,
                                      logger=ANY,
                                      rbac_permissions=mock_request.context['token_info']['rbac_policies']
                                      )
    mock_exc.assert_called_once_with(mock_dfunc.return_value)
    mock_remove.assert_called_once_with(f_kwargs)
    assert isinstance(result, ConnexionResponse)


@pytest.mark.asyncio
@patch('api.controllers.vulnerability_controller.DistributedAPI.distribute_function', return_value=AsyncMock())
@patch('api.controllers.vulnerability_controller.remove_nones_to_dict')
@patch('api.controllers.vulnerability_controller.DistributedAPI.__init__', return_value=None)
@patch('api.controllers.vulnerability_controller.raise_if_exc', return_value=CustomAffectedItems())
async def test_get_last_scan_agent(mock_exc, mock_dapi, mock_remove, mock_dfunc, mock_request):
    """Verify 'get_vulnerability_agent' endpoint is working as expected."""
    result = await get_last_scan_agent()
    f_kwargs = {'agent_list': [None]
                }
    mock_dapi.assert_called_once_with(f=vulnerability.last_scan,
                                      f_kwargs=mock_remove.return_value,
                                      request_type='distributed_master',
                                      is_async=False,
                                      wait_for_complete=False,
                                      logger=ANY,
                                      rbac_permissions=mock_request.context['token_info']['rbac_policies']
                                      )
    mock_exc.assert_called_once_with(mock_dfunc.return_value)
    mock_remove.assert_called_once_with(f_kwargs)
    assert isinstance(result, ConnexionResponse)


@pytest.mark.asyncio
@patch('api.controllers.vulnerability_controller.DistributedAPI.distribute_function', return_value=AsyncMock())
@patch('api.controllers.vulnerability_controller.remove_nones_to_dict')
@patch('api.controllers.vulnerability_controller.DistributedAPI.__init__', return_value=None)
@patch('api.controllers.vulnerability_controller.raise_if_exc', return_value=CustomAffectedItems())
async def test_get_vulnerabilities_severity_summary(mock_exc, mock_dapi, mock_remove, mock_dfunc,
                                                    mock_request):
    """Verify 'get_vulnerabilities_severity_summary' endpoint is working as expected."""
    result = await get_vulnerabilities_field_summary()
    f_kwargs = {
        'agent_list': [None],
        'field': None,
        'limit': DATABASE_LIMIT
    }
    mock_dapi.assert_called_once_with(f=vulnerability.get_inventory_summary,
                                      f_kwargs=mock_remove.return_value,
                                      request_type='distributed_master',
                                      is_async=False,
                                      wait_for_complete=False,
                                      logger=ANY,
                                      rbac_permissions=mock_request.context['token_info']['rbac_policies']
                                      )
    mock_exc.assert_called_once_with(mock_dfunc.return_value)
    mock_remove.assert_called_once_with(f_kwargs)
    assert isinstance(result, ConnexionResponse)
